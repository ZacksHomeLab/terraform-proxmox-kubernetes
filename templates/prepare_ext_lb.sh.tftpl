#!/bin/bash

export DEBIAN_FRONTEND=noninteractive

exec 3>&1 4>&2
trap 'exec 2>&4 1>&3' 0 1 2 3 15
exec 1>>/tmp/log.out 2>&1

user_id=$(id -u)
ip=${vm_ip}
state=${keepalive_state}
virtual_ip=${apiserver_vip}
apiserver_dest_port=${apiserver_dest_port}
keepalive_pass=${keepalive_pass}
router_id=${keepalive_router_id}

if [ "$state" == "MASTER" ]; then
  $priority = 100
else
  $priority = 99
fi

function pre_check() {

  echo "pre_check: Validating required variables are set."

  echo "pre_check: Check if running as Sudo."
  if [ $user_id -gt 0 ]; then
    echo "pre_check: This script requires sudo privilege to run. Stopping"
    exit 1
  fi

  echo "pre_check: Check if Keepalive Router ID is greater than 0."
  if [ ! $router_id -gt 0]; then
    echo "pre_check: router_id must be greater than 0. Stopping."
    exit 1
  fi

  echo "pre_check: Check if API Server Destination Port is greater than 0."
  if [ ! $apiserver_dest_port -gt 0]; then
    echo "pre_check: apiserver_dest_port must be greater than 0. Stopping."
    exit 1
  fi

  echo "pre_check: Check if provided IP Address exists on server"
  if [ ! -n "$(hostname -I | grep $ip)" ]; then
    echo "pre_check: IP $ip does not exist on this server. Stopping."
    exit 1
  fi

  echo "pre_check: Check if State is set correctly."
  if [ ! "$state" == "MASTER" ] && [ ! "$state" == "BACKUP" ];
    echo "pre_check: State is missing. It should be MASTER or BACKUP."
    exit 1
  fi

  echo "pre_check: Check if keepalive_pass is set."
  if [ ! -n "$keepalive_pass" ]; then
    echo "pre_check: Keepalive pass is not set. Stopping."
    exit 1
  fi

}

function get_package_provider() {
  # Determine our package provider
  local os_type=$(grep ^ID_LIKE /etc/os-release | cut -f2 -d=)

  if [ "$os_type" = "debian" ]; then

    # Check if apt-get is installed
    local test_command=$(command -v apt-get)
    if [ -n "$($test_command | tr -d '[:space:]')" ]; then
      echo "apt-get"
    else

      # Check if apt-get is installed
      local test_command=$(command -v apt)
      if [ -n "$($test_command | tr -d '[:space:]')" ]; then
        echo "apt"
      else

        # Neither apt or apt-get exist
        echo "upgrade_packages: Can not find 'apt' or 'apt-get'"
        exit 1
      fi
    fi
  fi
}

function is_apt_lock() {
  lsof -t "/var/lib/apt/lists/lock" >/dev/null 2>&1 ||
  lsof -t "/var/lib/dpkg/lock-frontend" >/dev/null 2>&1 ||
  lsof -t "/var/lib/dpkg/lock" >/dev/null 2>&1
}

function wait_for_apt_unlock() {

  local apt_lock_max_wait_time=600
  local apt_retry_interval=10
  local wait_time=0

  while is_apt_lock; do
    if [ "$wait_time" -ge "$apt_lock_max_wait_time" ]; then
      echo "wait_for_apt_unlock: Timeout reached. Lock file is still present."
      exit 1
    fi
    echo "wait_for_apt_unlock: Waiting for apt lock file to be released..."
    sleep $apt_retry_interval
    wait_time=$((wait_time + $apt_retry_interval))
  done
}

function upgrade_packages() {

  case $package_provider in
    apt)
        wait_for_apt_unlock
        apt -qqy upgrade
      ;;

    apt-get)
        # The timeout is to prevent E: Unable to acquire the dpkg frontend lock
        wait_for_apt_unlock
        apt-get -qqy -o DPkg::Lock::Timeout=60 upgrade
      ;;

    *)
      echo "upgrade_packages: Unknown package provider."
      exit 1
      ;;
  esac

  if [ $? -ne 0 ]; then
    echo "upgrade_packages: 'apt' failed upgrading with exit code '$?'"
    exit 1
  fi
}

function update_packages() {

  case $package_provider in
    apt)
        wait_for_apt_unlock
        apt -qqy update
      ;;

    apt-get)
        wait_for_apt_unlock
        apt-get -qqy -o DPkg::Lock::Timeout=60 update
      ;;

    *)
      echo "update_packages: Unknown package provider."
      exit 1
      ;;
  esac

  if [ $? -ne 0 ]; then
    echo "update_packages: '$package_provider' failed updating with exit code '$?'"
    exit 1
  fi
}

function install_packages() {

  packages=$(printf "%s " "$@")

  case $package_provider in
    apt)
        wait_for_apt_unlock
        apt -qqy install $packages
      ;;

    apt-get)
        wait_for_apt_unlock
        apt-get -qqy -o DPkg::Lock::Timeout=60 install $packages
      ;;

    *)
      echo "install_packages: Unknown package provider."
      exit 1
      ;;
  esac

  if [ $? -ne 0 ]; then
    echo "install_packages: '$package_provider' failed installing packages with exit code '$?'"
    exit 1
  fi
}

function remove_packages() {
  packages=$(printf "%s " "$@")

  case $package_provider in
    apt)
        wait_for_apt_unlock
        apt -qqy remove $packages
      ;;

    apt-get)
        wait_for_apt_unlock
        apt-get -qqy -o DPkg::Lock::Timeout=60 remove $packages
      ;;

    *)
      echo "remove_packages: Unknown package provider."
      exit 1
      ;;
  esac

  if [ $? -ne 0 ]; then
    echo "remove_packages: '$package_provider' failed removing packages with exit code '$?'"
    exit 1
  fi

}

function prepare_env() {
  # Install / Upgrade packages
  echo "prepare_env: Performing updates/upgrades..."

  update_packages
  upgrade_packages

  # Install required packages
  echo "prepare_env: Installing required packages..."
  install_packages curl gnupg lsb-release git wget jq

  # Disable Swap
  echo "prepare_env: Disabling swap..."
  swapoff -a
  sed -i 's/^\/swap/#\/swap/' /etc/fstab
}

function install_keepalived() {
  install_packages keepalived
}

function setup_keepalived() {

  local keepalive_conf="/etc/keepalived/keepalived.conf"
  local apiserver_check_script="/etc/keepalived/check_apiserver.sh"

  echo "setup_keepalive: Step 1a - Creating $keepalive_conf"
  tee $keepalive_conf <<EOF
global_defs {
    router_id LVS_DEVEL
}
vrrp_script check_apiserver {
  script "/etc/keepalived/check_apiserver.sh"
  interval 3
  weight -2
  fall 10
  rise 2
}

vrrp_instance VI_1 {
    state $state
    interface $nic
    virtual_router_id $router_id
    priority $priority
    authentication {
        auth_type PASS
        auth_pass $keepalive_pass
    }
    virtual_ipaddress {
        $virtual_ip
    }
    track_script {
        check_apiserver
    }
}
EOF

  echo "setup_keepalive: Step 1b - Verify is keepalived.conf exists after creation."
  if [ ! -e "$keepalive_conf" ]; then
    echo "setup_keepalive: file '$keepalive_conf' does not exist. Stopping."
    exit 1
  fi

  echo "setup_keepalive: Step 2a - Creating $apiserver_check_script"
  tee $apiserver_check_script <<EOF
#!/bin/sh

errorExit() {
    echo "*** $*" 1>&2
    exit 1
}

curl --silent --max-time 2 --insecure https://localhost:$apiserver_dest_port/ -o /dev/null || errorExit "Error GET https://localhost:$apiserver_dest_port/"
if ip addr | grep -q $virtual_ip; then
    curl --silent --max-time 2 --insecure https://$virtual_ip:$apiserver_dest_port/ -o /dev/null || errorExit "Error GET https://$virtual_ip:$apiserver_dest_port/"
fi
EOF

  echo "setup_keepalive: Step 2b - Verify is check_apiserver exists after creation."
  if [ ! -e "$apiserver_check_script" ]; then
    echo "setup_keepalive: file '$apiserver_check_script' does not exist. Stopping."
    exit 1
  fi

  echo "setup_keepalive: Step 3 - Done"
}

function get_nic_name() {

  # Retrieve network adapter name (e.g., eth0, eth1)
  local adapter=$(ip addr | awk -vtarget_addr=$ip '
/^[0-9]+/ {
  iface=substr($2, 0, length($2)-1)
}

$1 == "inet" {
  split($2, addr, "/")
  if (addr[1] == target_addr) {
    print iface
  }
}
')

  if [ ! -n "$adapter" ]; then
    echo "get_nic_name: Did not find a network adapter matching the provided IP Address. Stopping."
    exit 1
  else
    echo $adapter
  fi
}

echo "Validate variables..."
pre_check

package_provider=$(get_package_provider)

echo "Gathering network adapter name based off of IP $ip"
nic=$(get_nic_name)

echo "Waiting for apt lock..."
wait_for_apt_unlock

echo "Prepare virtual machine with required packages..."
prepare_env

echo "Installing docker..."
install_keepalived

echo "Configuring keepalived..."
setup_keepalived
