#!/bin/bash

export DEBIAN_FRONTEND=noninteractive

exec 3>&1 4>&2
trap 'exec 2>&4 1>&3' 0 1 2 3 15
exec 1>>/tmp/log.out 2>&1

apt_lock_max_wait_time=600
apt_retry_interval=10

ips=$(hostname -I)
first_ip=$(echo $IP | cut -d' ' -f1)

pod_network="${pod_network}"
service_network="${service_network}"

cluster_domain="${cluster_domain}"
cluster_name="${cluster_name}"
cluster_namespace="${cluster_namespace}"

hostname=$(hostname | tr '[:upper:]' '[:lower:]')
user_id=$(id -u)

ssl_data=$1
ssl_data_destination="${cert_destinations}"

# Pre-Check: Verify if sudo
if [ $user_id -ne 0 ]; then
    echo "Pre-Check: This script requires sudo privilege to run."
    exit 1
fi

# Determine our package provider
os_type=$(grep ^ID_LIKE /etc/os-release | cut -f2 -d=)
if [ "$os_type" = "debian" ]; then

  # Check if apt is installed
  get_package_provider=$(command -v apt)
  if [ -n "$($get_package_provider | tr -d '[:space:]')" ]; then
    package_provider="apt-get"
  else

    # Check if apt-get is installed
    get_package_provider=$(command -v apt)
    if [ -n "$($get_package_provider | tr -d '[:space:]')" ]; then
      package_provider="apt"
    else

      # Neither apt or apt-get exist
      echo "upgrade_packages: Can not find 'apt' or 'apt-get'"
      exit 1
    fi
  fi
fi

function is_apt_lock() {
  lsof -t "/var/lib/apt/lists/lock" >/dev/null 2>&1 ||
  lsof -t "/var/lib/dpkg/lock-frontend" >/dev/null 2>&1 ||
  lsof -t "/var/lib/dpkg/lock" >/dev/null 2>&1
}

function wait_for_apt_unlock() {

  wait_time=0
  while is_apt_lock; do
    if [ "$wait_time" -ge "$apt_lock_max_wait_time" ]; then
      echo "Timeout reached. Lock file is still present."
      exit 1
    fi
    echo "Waiting for apt lock file to be released..."
    sleep $apt_retry_interval
    wait_time=$((wait_time + $apt_retry_interval))
  done
}

function upgrade_packages() {

  case $package_provider in
    apt)
        apt -qqy upgrade
      ;;

    apt-get)
        # The timeout is to prevent E: Unable to acquire the dpkg frontend lock
        wait_for_apt_unlock
        apt-get -qqy -o DPkg::Lock::Timeout=60 upgrade
      ;;

    *)
      echo "upgrade_packages: Unknown package provider."
      exit 1
      ;;
  esac

  if [ $? -ne 0 ]; then
    echo "upgrade_packages: 'apt' failed upgrading with exit code '$?'"
    exit 1
  fi
}

function update_packages() {

  case $package_provider in
    apt)
        apt -qqy update
      ;;

    apt-get)
        wait_for_apt_unlock
        apt-get -qqy -o DPkg::Lock::Timeout=60 update
      ;;

    *)
      echo "update_packages: Unknown package provider."
      exit 1
      ;;
  esac

  if [ $? -ne 0 ]; then
    echo "update_packages: '$package_provider' failed updating with exit code '$?'"
    exit 1
  fi
}

function install_packages() {
  packages=$(printf "%s " "$@")

  case $package_provider in
    apt)
        apt -qqy install $packages
      ;;

    apt-get)
        wait_for_apt_unlock
        apt-get -qqy -o DPkg::Lock::Timeout=60 install $packages
      ;;

    *)
      echo "install_packages: Unknown package provider."
      exit 1
      ;;
  esac

  if [ $? -ne 0 ]; then
    echo "install_packages: '$package_provider' failed installing packages with exit code '$?'"
    exit 1
  fi
}

function remove_packages() {
  packages=$(printf "%s " "$@")

  case $package_provider in
    apt)
        apt -qqy remove $packages
      ;;

    apt-get)
        wait_for_apt_unlock
        apt-get -qqy -o DPkg::Lock::Timeout=60 remove $packages
      ;;

    *)
      echo "remove_packages: Unknown package provider."
      exit 1
      ;;
  esac

  if [ $? -ne 0 ]; then
    echo "remove_packages: '$package_provider' failed removing packages with exit code '$?'"
    exit 1
  fi

  os_type=$(grep ^ID_LIKE /etc/os-release | cut -f2 -d=)
}

function prepare_env() {
  # Install / Upgrade packages
  echo "prepare_env: Performing updates/upgrades..."

  update_packages
  upgrade_packages

  # Install required packages
  echo "prepare_env: Installing required packages..."
  install_packages curl gnupg lsb-release git wget jq

  # Disable Swap
  echo "prepare_env: Disabling swap..."
  swapoff -a
  sed -i 's/^\/swap/#\/swap/' /etc/fstab
}

function install_docker() {
  # Remove currently installed docker packages
  echo "install_docker: Removing installed docker packages..."
  remove_packages docker.io docker-doc docker-compose podman-docker containerd runc

  # Prepare apt-cache for docker packages
  echo "install_docker: Installing docker's keyring..."
  mkdir -p /etc/apt/keyrings
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \
    gpg --dearmor -o /etc/apt/keyrings/docker.gpg

  echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
    https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | \
    tee /etc/apt/sources.list.d/docker.list > /dev/null

  # Install docker
  echo "install_docker: Installing docker..."
  update_packages
  install_packages docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
}

function install_docker_runtime() {
  initial_dir=$(pwd)

  cd /tmp
  wget https://storage.googleapis.com/golang/getgo/installer_linux
  chmod +x ./installer_linux
  ./installer_linux
  source ~/.bash_profile

  # Download the runtime
  git clone https://github.com/Mirantis/cri-dockerd.git

  # Prepare docker runtime
  cd cri-dockerd
  mkdir bin
  go build -o bin/cri-dockerd

  # Install docker runtime
  install -o root -g root -m 0755 bin/cri-dockerd /usr/local/bin/cri-dockerd

  # Prepare docker runtime with systemd
  cp -a packaging/systemd/* /etc/systemd/system
  sed -i -e 's,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,' /etc/systemd/system/cri-docker.service
  systemctl daemon-reload
  systemctl enable cri-docker.service
  systemctl enable --now cri-docker.socket

  cd $initial_dir

  # Cleanup time
  rm -rf /tmp/installer_linux /tmp/cri-dockerd
}

function install_k8() {
  # Prepare apt to download Kubeadm, Kubectl, and Kubelet
  curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | \
    gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg
  echo "deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | \
    tee /etc/apt/sources.list.d/kubernetes.list

  update_packages
  install_packages kubelet kubeadm kubectl
}

function import_ssl_certs() {

  # Add quotes around the provided JSON data from Terraform. This is to prevent jq from getting an error
  # as it expects quotes around each key=value.
  json_data=$(echo $ssl_data | sed -E 's/([0-9]+):(\{[^}]+\})/"\1":\2/g; s/([a-zA-Z0-9]+):([^,}]+)/"\1":"\2"/g')

  for i in $(echo $json_data | jq -r 'keys[]'); do
    content=$(echo "$json_data" | jq -r ".[\"$i\"].content")
    destination=$(echo "$json_data" | jq -r ".[\"$i\"].destination")
    directory=$(dirname $destination)

    if [ ! -d $directory ]; then
      mkdir --parents $directory

      if [ $? -ne 0 ]; then
        echo "import_ssl_certs: Error creating directory $directory"
        exit 1
      fi
    fi

    echo $content | tee $destination &>1

    if [ $? -ne 0 ]; then
      echo "import_ssl_certs: Error adding content to destination $destination"
      exit 1
    fi
  done
}

function verify_ssl_certs() {

  echo "verify_ssl_certs: Verifying if certificate files need to be modified."

  if [ -z "$ssl_data_destination" ]; then
    echo "verify_ssl_certs: The script is expecting certificate destinations but none exist. Stopping."
    exit 1
  fi

  # If number of lines equals one, add new lines based on certificate data
  for file in $ssl_data_destination; do
    if [ -s "$file" ]; then
      if [ $(sed -n '$=' $file) -eq 1 ]; then
        # Retrieve contents of file
        # separate the end of the certificate with the start of ----END
        # set the width of each line to 64 characters
        # remove empty whitespace lines and remove lines that start with a space
        # save the file
        #cat $file | sed -E 's/= -/=\n-/g' | fold -s -w 64 | sed -e '/^ $/d' -e '/^\s/d' | tee $file &>1
        cat $file | sed -e 's/\s-----END/\n-----END/g' -e 's/-----\s/-----\n/g' | fold -s -w 64 | sed -e '/^ $/d' -e 's/^\s//g' | tee $file &>1

        if [ $? -ne 0 ]; then
          echo "verify_ssl_certs: Error verifying SSL certificate $file"
          exit 1
        fi
      fi
    fi
  done
}

function init_control_node() {
  kubeadm init \
    --pod-network-cidr=$pod_network \
    --service-cidr=$service_network \
    --service-dns-domain=$cluster_domain \
    %{ if kube_token != null ~}
    --token "${kube_token}" \
    --token-ttl 0 \
    %{ endif ~}
    --cri-socket=unix:///var/run/cri-dockerd.sock

  if [ "$user_id" -ne 0 ]; then
    mkdir -p $HOME/.kube
    sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
    sudo chown $(id -u):$(id -g) $HOME/.kube/config
  else
    export KUBECONFIG=/etc/kubernetes/admin.conf
  fi
}

function init_pod_network() {
  kubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml
}

function deploy_on_control_plane() {
  kubectl taint nodes $hostname node-role.kubernetes.io/control-plane:NoSchedule --overwrite
}

function deploy_on_master() {
  kubectl taint nodes $hostname node-role.kubernetes.io/master=:NoSchedule --overwrite
}

wait_for_apt_unlock
prepare_env
install_docker
install_docker_runtime
install_k8
%{ if import_ssl ~}
import_ssl_certs
verify_ssl_certs
%{ endif ~}
init_control_node
init_pod_network
%{ if pods_on_control_node ~}
#deploy_on_control_plane
%{ endif ~}
